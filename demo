#!/usr/bin/env bash
set -e -u -o pipefail

declare -r SCRIPT_DIR=$(cd -P $(dirname $0) && pwd)

declare -r NAMESPACE=${NAMESPACE:-catalog-tests}

_log() {
  local level=$1
  shift
  echo -e "$level: $@"
}

log.err() {
  _log "ERROR" "$@" >&2
}

info() {
  _log "\nINFO" "$@"
}

err() {
  local code=$1
  shift
  local msg="$@"
  log.err $msg
  exit $code
}

valid_command() {
  local fn=$1
  [[ $(type -t "$fn") == "function" ]]
}

execute() {
  echo "Running:  '$@'"
  ${DRY_RUN:-false} || "$@"
}

demo.validate() {
  info "validating tools"

  tkn version >/dev/null 2>&1 || err 1 "No tkn binary found"
  oc version >/dev/null 2>&1 || err 1 "No oc binary found"
  return 0
}

declare -r TASKS_DIR=tmp/tasks

demo.logs() {
  TKN tr logs "$@" -f
}

demo.test() {

  demo.validate

  info "Ensure namespace $NAMESPACE exists"
  oc get ns "$NAMESPACE" 2>/dev/null || {
    oc new-project $NAMESPACE
  }

  # if no argument was specified, run all tests
  if [ "$#" -eq 0 ]; then
    local clustertasks="$(ls -d */)"
  else
    local clustertasks=$@
  fi

  for clustertask in $clustertasks; do
    # remove trailing slash and subdirs (a -> a, b/ -> b, c/d/e -> c)
    local testname=${clustertask%%/*}
    local maxloop=60 # 10 minutes max

    # Create the task and resources
    for yaml in ${testname}/*.yaml; do
      [ -f "$yaml" ] || continue
      oc replace -n ${NAMESPACE} -f ${yaml}
    done

    # Create task runs
    for yaml in ${testname}/tests/*.yaml; do
      [ -f "$yaml" ] || continue
      pr=$(oc create -n ${NAMESPACE} -f ${yaml} -o jsonpath={.metadata.name})

      local cnt=0
      while true; do
        [[ ${cnt} == ${maxloop} ]] && failed_tests+=(${pr})
        echo "---- ${pr}"
        status=$(oc -n ${NAMESPACE} get pipelinerun ${pr} --output=jsonpath='{.status.conditions[*].status}')
        info "Pipelinerun: ${pr} -> status: ${status}"
        reason=$(oc -n ${NAMESPACE} get pipelinerun ${pr} --output=jsonpath='{.status.conditions[*].reason}')
        info "Pipelinerun: ${pr} -> reason: ${reason}"
        [[ ${status} == *ERROR || ${reason} == *Failed || ${reason} == CouldntGetTask ]] && failed_tests+=(${pr})
        [[ ${status} == True ]] && {
          info "SUCCESS: ${pr} pipelinerun has successfully executed"
          # tkn pr logs -n ${NAMESPACE} -f ${pr}
          break
        }
        sleep 10
        cnt=$((cnt + 1))
      done
    done
  done

  show_failures $failed_tests
}

show_failures() {
  info "==========================="
  info "List of failed tests:"
  local pipelineruns=$1
  for pr in "${pipelineruns[@]}"; do
    echo "${pr}"
  done
  info "==========================="
  # tkn pr logs -n ${NAMESPACE} -f ${pipelinerun}
  if [ ${#pipelineruns[@]} -eq 0 ]; then
    exit 0
  else
    exit 1
  fi
}

demo.help() {
  cat <<-EOF
		USAGE:
		  $0 [command]

		COMMANDS:
		  test   Runs catalog E2E tests, runs all tests when no parameter specified
EOF

}

main() {
  local fn="demo.${1:-help}"
  valid_command "$fn" || {
    demo.help
    err  1 "invalid command '$1'"
  }

  if [ "$#" -gt 0 ]; then
    shift
  fi
  cd $SCRIPT_DIR

  $fn "$@"
  return $?
}

main "$@"
