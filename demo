#!/usr/bin/env bash
set -e -u -o pipefail

declare -r SCRIPT_DIR=$(cd -P $(dirname $0) && pwd)

declare -r NAMESPACE=${NAMESPACE:-tekton-catalog}

_log() {
  local level=$1
  shift
  echo -e "$level: $@"
}

log.err() {
  _log "ERROR" "$@" >&2
}

info() {
  _log "\nINFO" "$@"
}

err() {
  local code=$1
  shift
  local msg="$@"
  log.err $msg
  exit $code
}

valid_command() {
  local fn=$1
  [[ $(type -t "$fn") == "function" ]]
}

execute() {
  echo "Running:  '$@'"
  ${DRY_RUN:-false} || "$@"
}

# helpers to avoid adding -n $NAMESPACE to oc and tkn
OC() {
  echo oc -n ${NAMESPACE} "$@"
  oc -n ${NAMESPACE} "$@"
}

TKN() {
  echo tkn -n ${NAMESPACE} "$@"
  tkn -n ${NAMESPACE} "$@"
}

demo.validate() {
  info "validating tools"

  tkn version >/dev/null 2>&1 || err 1 "no tkn binary found"
  oc version >/dev/null 2>&1 || err 1 "no oc binary found"
  return 0
}

declare -r TASKS_DIR=tmp/tasks

demo.logs() {
  TKN tr logs "$@" -f
}

demo.runE2E() {

  demo.validate

  info "ensure namespace $NAMESPACE exists"
  OC get ns "$NAMESPACE" 2>/dev/null || {
    OC new-project $NAMESPACE
  }

  # if no argument was specified, run all tests
  if [ "$#" -eq 0 ]; then
    local clustertasks="$(ls -d */)"
  else
    local clustertasks=$@
  fi

  for clustertask in $clustertasks; do
    # remove trailing slash and subdirs (a -> a, b/ -> b, c/d/e -> c)
    local testname=${clustertask%%/*}
    local maxloop=60 # 10 minutes max

    # Create the task and resources
    for yaml in ${testname}/*.yaml; do
      OC create -f ${yaml}
    done

    # Create task runs
    for yaml in ${testname}/tests/*.yaml; do
      OC create -f ${yaml}
    done

    taskruns=$(oc get tr -o=jsonpath='{.items[*].metadata.name}')
    for tr in $taskruns; do
      local cnt=0
      while true; do
        [[ ${cnt} == ${maxloop} ]] && show_failure ${testname} ${tr}

        status=$(oc -n ${NAMESPACE} get taskrun ${tr} --output=jsonpath='{.status.conditions[*].status}')
        info "taskrun: ${tr} -> status: ${status}"
        reason=$(oc -n ${NAMESPACE} get taskrun ${tr} --output=jsonpath='{.status.conditions[*].reason}')
        info "taskrun: ${tr} -> reason: ${reason}"
        [[ ${status} == *ERROR || ${reason} == *Failed || ${reason} == CouldntGetTask ]] && show_failure ${testname} ${tr}
        [[ ${status} == True ]] && {
          info "SUCCESS: ${tr} taskrun has successfully executed: "
          TKN tr logs -f ${tr}
          break
        }
        sleep 10
        cnt=$((cnt + 1))
      done
    done
  done
}

show_failure() {
  local testname=$1
  local taskrun=$2
  info "FAILED: \"${testname}\" Clustertask has failed to execute properly"
  info "--- Taskrun Dump"
  OC get tr ${taskrun} -o yaml
  info "--- Taskrun Logs"
  TKN tr logs -f ${taskrun}
  exit 1
}

demo.help() {
  cat <<-EOF
		USAGE:
		  $0 [command]

		COMMANDS:
		  runE2E   Runs catalog E2E tests, runs all tests when no parameter specified
EOF

}

main() {
  local fn="demo.${1:-help}"
  valid_command "$fn" || {
    demo.help
    err  1 "invalid command '$1'"
  }

  if [ "$#" -gt 0 ]; then
    shift
  fi
  cd $SCRIPT_DIR

  $fn "$@"
  return $?
}

main "$@"
